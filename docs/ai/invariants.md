# Invariants (Non-Negotiable Rules)

Canonical, single-source rules that must never be violated. If any rule is broken, resulting work is incorrect.

---

## Test-Driven Development

### TDD-1: Tests Must Fail When Features Are Missing
```
IF:   Intentional vulnerability not implemented OR broken
THEN: uctest AND ucdemo MUST show failures

IF:   Previous vulnerability not mitigated in current exercise
THEN: uctest AND ucdemo MUST show failures

IF:   uctest AND ucdemo show zero failures
THEN: All intentional vulns work AND all previous vulns are mitigated
```
Never silence tests, mock assertions, or make tests pass artificially when functionality is broken or missing.

### TDD-2: Tests Are Specifications
- E2E specs define intended behavior before implementation.
- Demos assert exploit success/failure before code is complete.
- Failing test = valuable signal, not a problem to hide.
- Options after a failure: (1) fix code, (2) fix test if wrong, (3) acknowledge incomplete work.

### TDD-3: Never Chase Green Bars
| Action | Verdict |
|--------|---------|
| Disabling a test to make suite green | FORBIDDEN |
| Mocking to avoid real test | FORBIDDEN |
| Removing failing assertion | FORBIDDEN (unless assertion itself is wrong) |
| Commenting out problematic test | FORBIDDEN |
| Adding `@skip`/`@disabled` | FORBIDDEN |

---

## HTTP Assertions & Syntax Invariants

### HTTP-1: No Quotes on Right-Hand Side
```http
# CORRECT
?? js $(response).field("status") == pending
?? js response.parsedBody.email == plankton@chum-bucket.sea

# WRONG - causes syntax error or comparison failure
?? js $(response).field("status") == "pending"
?? js response.parsedBody.email == "plankton@chum-bucket.sea"
```

### HTTP-2: Operator Required
```http
# WRONG - becomes request body, causes 500
?? js response.parsedBody.isValid
?? js $(response).field("active")

# CORRECT
?? js response.parsedBody.isValid == true
?? js $(response).field("active") == true
```

### HTTP-3: Demo vs Spec Response Syntax
| Context | Status | Field | Example |
|---------|--------|-------|---------|
| Demo (ucdemo) | `response.status` | `response.parsedBody.field` | `?? js response.parsedBody.email == x` |
| Spec (uctest)  | `$(response).status()` | `$(response).field("x")` | `?? js $(response).field("email") == x` |
Using `$(response)` in demos is undefined. Using `response.parsedBody` in specs is non-standard.

### HTTP-4: Never Edit `~` Files
`~` prefixed spec files are auto-generated by `ucsync`. To change behavior: create a non-`~` override or add an exclusion in `spec/spec.yml`.

---

## Character Invariants

### CHAR-1: Attacker Uses OWN Credentials
```http
# WRONG - password theft, not vulnerability demonstration
Authorization: Basic {{btoa("spongebob:bikinibottom")}}
GET /messages?user=patrick

# CORRECT - attacker creds, victim data via confusion
Authorization: Basic {{btoa("plankton:i_love_my_wife")}}
GET /messages?user=patrick
```

### CHAR-2: SpongeBob Is Never the Attacker
| Character | Valid Attacker? | Valid Victim? |
|-----------|-----------------|---------------|
| SpongeBob | NEVER           | YES |
| Squidward | YES (insider)   | Sometimes |
| Plankton  | YES (external)  | No |
| Patrick   | No              | YES (VIP) |
| Mr. Krabs | No              | YES (business target) |
| Sandy     | Rarely attacker | YES |

### CHAR-3: Attack Relationships Must Be Plausible
```
Squidward -> SpongeBob (spite, coworker jealousy)
Squidward -> Mr. Krabs (workplace grievance)
Plankton  -> Mr. Krabs (business rivalry)
Plankton  -> Patrick (easy target)
```
Invalid example: Plankton -> SpongeBob (no direct relationship).

---

## Inheritance Invariants

### INH-1: Optimize for Maximum Inheritance
Prioritize smallest possible .http files, reuse via imports, minimal overrides, and grouping assertions by lifecycle (appear/disappear together).

### INH-2: Inheritance Chain Must Be Respected
When a vulnerability is fixed in vN+1, either exclude the vuln test in `spec/spec.yml` or override it; regenerated `~` files must reflect the change.

### INH-3: Breaking Changes Are Rare
Real SaaS apps rarely break compatibility. If many overrides are needed, reconsider design. Exclusions should be limited to actual behavior changes (vuln fixed, API change).

---

## Code Quality Invariants

### CODE-1: Vulnerabilities Must Be Subtle
Production-quality code that a rushed but competent developer could write. No cartoonish `vulnerable_function()` or obvious warnings.

### CODE-2: `@unsafe` Annotation Required
Every intentional vulnerability must be marked nearby:
```python
# @unsafe {
#     "vuln_id": "v301",
#     "severity": "high",
#     "category": "authorization-confusion",
#     "description": "Behavioral description of confusion"
# }
def vulnerable_function():
    ...
```

### CODE-3: One Concept Per Exercise
Each exercise teaches exactly one confusion pattern. Complexity comes from evolution, not stacking multiple unrelated bugs.

---

## Verification Commands (Always Available)
```bash
# Verify demos pass
ucdemo r03            # All demos in section 03

# Verify specs pass
uctest v301/          # All specs for version 301

# Regenerate inherited specs
ucsync                # After spec.yml changes

# Check docker logs
uclogs --tail=50      # Recent application logs
```
If both `uctest` and `ucdemo` pass with zero failures, TDD invariants are satisfied.
