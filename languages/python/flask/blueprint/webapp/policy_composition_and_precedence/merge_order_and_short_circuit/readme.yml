---
title: Merge Order and Short-Circuit Pitfalls
summary: |
  Layering a permissive guard ahead of a stricter policy, or returning early from a cache, means the stronger rule does not execute.
description: |
  ## Overview
  Security controls in Flask—decorators, blueprints, before_request hooks—execute in a specific order. When a permissive check runs before a stricter policy, or when middleware returns early before handler-level guards execute, the stronger protection never runs. Flask applies decorators bottom-up (the outermost decorator runs first), so a guard decorator placed above an auth decorator will execute before authentication state is prepared. Even when all components agree on data sources, incorrect execution sequencing creates authorization bypasses. This is distinct from parsing drift: the vulnerability exists purely in the temporal ordering of security checks, not in how they interpret request data.

  **Practice tips:**
  - Audit decorator order whenever mixing auth, caching, and convenience helpers. Remember: outer decorators run FIRST in Flask.
  - Ensure guards don't depend on state (`g.*`) that inner decorators haven't set yet.
  - Ensure middleware that returns responses still enforces critical checks.
  - Write regression tests that show the stricter guard running in the expected order and seeing prepared state.
  - When debugging bypasses, check BOTH execution order AND data sourcing—vulnerabilities often involve both dimensions.
category: policy-composition-and-precedence.merge-order-and-short-circuit
namespace: flask-policy-merge-order
toc: true
outline:
  - title: Decorator Execution Order Bypasses
    description: |
      Guards that run before authentication or state preparation become no-ops, allowing unauthorized access.
    examples:
      - 16
