---
title: Multi-Value Semantics in Flask Requests
summary: |
  Repeated parameters show up as strings, lists, or the first item depending on how they are read; when guards and handlers pick different helpers, multivalue input turns into a bypass.
description: |
  ## Overview
  Web forms and query strings support repeated keys: `role=admin&role=auditor`. Flask surfaces those repetitions through helpers like `.getlist()` while `.get()` only returns the first match. When security checks and business logic disagree on which API to use - or on whether to expect a list vs a scalar - the door opens to privilege escalation and logic bypasses.

  **When debugging or reviewing:**
  - Identify whether user input can be repeated (multi-select UI, query arrays, batching endpoints).
  - Check if the guard uses `.get()` while downstream loops over `.getlist()` (or vice versa).
  - Pay attention to `any()` vs `all()` semantics when interpreting lists of roles or permissions.

  The examples listed still live in `confusion/parameter_source/r06_multi_value/` and will migrate here.
category: ii.multi-value-semantics
namespace: flask-ii-multi-value-semantics
toc: true
outline:
  - title: Simple List vs Scalar Checks
    description: |
      Baseline flows that accept the first value only - and how they miss the repeated parameter attack.
    examples:
      - 10
  - title: Shared Utilities with Divergent Expectations
    description: |
      Helpers reuse inconsistent getters, causing the guard and action to disagree about the caller's privileges.
    examples:
      - 11
  - title: Batching & Quantifier Pitfalls
    description: |
      `any()` vs `all()` and similar logic slips that turn a single bad entry into a successful bypass.
    examples:
      - 12