---
title: Normalization & Canonicalization Traps in Flask
summary: |
  Normalizing input (lowercasing, trimming, decoding) helps comparisons, but if only some code paths do it, attackers can present the same value in two different skins.
description: |
  ## Overview
  Canonicalization is meant to make comparisons simple: lowercase the e-mail, strip surrounding spaces, normalize Unicode, decode `%2F`. The bug shows up when only **some** parts of the flow canonicalize a value. Guards may validate raw input while storage or lookup uses the normalized form (or the reverse), giving attackers a way to smuggle alternate representations.

  **What to watch for in Flask apps:**
  - Decorators that normalize user IDs before storing them in `g`, while downstream code trusts the raw path parameter.
  - Database helpers that lowercase keys but uniqueness checks run before the transform.
  - Pydantic or Marshmallow models that strip whitespace, yet guards compare the unstripped string.

  The cases below come from the current `confusion/canonicalization/` samples and will migrate into this bucket.
category: ii.normalization-canonicalization
namespace: flask-ii-normalization-canonicalization
toc: true
outline:
  - title: Case Canonicalization Issues
    description: |
      Lowercasing and case-insensitive comparisons differ depending on whether the code is validating, persisting, or authorizing access.
    examples:
      - 18
      - 19
  - title: Whitespace & Formatting Drift
    description: |
      Stripping spaces (or normalizing structured payloads) in only part of the stack quietly changes which record is read or updated.
    examples:
      - 20
      - 21