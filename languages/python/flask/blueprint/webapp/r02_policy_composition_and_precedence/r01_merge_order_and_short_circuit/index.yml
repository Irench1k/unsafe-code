version: '1'
root: .
category: policy-composition-and-precedence.merge-order-and-short-circuit
namespace: flask-policy-merge-order
examples:
  1:
    id: 1
    kind: block
    title: Authorization Bypass via Decorator Execution Order
    notes: >-
      We try to fix the root cause of the vulnerability here by enforcing correct merging
      order – view args take precedence over query args. Additionally, we enforce that only
      one of the two can be present.


      The code, however, remains vulnerable despite these efforts! This time, the problem
      is that the `@check_group_membership_v2` decorator is applied too early – before the
      `@basic_auth_v3` decorator which is responsible for setting the `g.group` global variable.
      This makes `@check_group_membership_v2` a no-op.


      This is a pure policy composition issue: the guard decorator executes before the authentication
      decorator prepares the state it depends on. Flask applies decorators bottom-up (outer
      decorator runs first), so @check_group_membership_v2 sees g.group = None and passes
      all requests.
    http: null
    language: python
    parts:
    - part: 1
      file: routes.py
      code_start_line: 25
      code_end_line: 30
    - part: 2
      file: decorator.py
      code_start_line: 15
      code_end_line: 46
    file_hashes:
      decorator.py: a6e9bb78e6d207474240f1e739178d5e57ecb62d4e30a4c69807f437856808ad
      routes.py: 15707bd05835f8faebba08b0d26b4db8e385d11a8f0c698318fbcdc6a613002b
    fingerprint: 5cf34c2d50dba3fc3fd4dc4396e6e315010aa4c7ff27e138c394c5553c6b2e25
attachments:
  http/exploit-1.http: 3704c642b65b7bff233df5cbcad9cbf0b38b6ccc873222055f5cfaa3c9a0823c
build_signature: bc37c3a95dadf63306d058e2a08cf5b423a8fb609c992965dc0d53c4adab3436
last_readme_fingerprint: 9c3602e7d19afa72f9578ac8af134bb459643843f222946873e48d18ce7bfbdf
