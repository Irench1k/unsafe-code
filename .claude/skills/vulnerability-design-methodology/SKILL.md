---
name: vulnerability-design-methodology
description: Designing educational vulnerabilities for Unsafe Code Lab. Auto-invoke when brainstorming new exercises, reading section READMEs, discussing vulnerability patterns, or asking "what should the vulnerability be?" Covers confusion categories, progressive complexity, and teaching goals.
---

# Vulnerability Design Methodology

## When to Use This Skill

- Designing new vulnerability exercises
- Reading/writing section README.md plans
- Discussing attack patterns and confusion types
- Evaluating if a vulnerability is "subtle enough"
- Asking "what should the vulnerability be?"

## When NOT to Use This Skill

- Implementing code (use vulnerable-code-patterns skill)
- Writing .http demos (use http-demo-conventions skill)
- Writing e2e specs (use http-spec-conventions skill)

## Design Principles

### 1. ONE Concept Per Exercise (Sacred Rule)

Each exercise introduces exactly ONE new security insight. Not zero, not two. ONE.

**Good**: "Session cookie vs URL parameter confusion"
**Bad**: "Session confusion AND input validation AND type coercion"

### 2. Production-Quality Code

Vulnerabilities hide in realistic code, not obvious bugs:
- Professional function names (`get_user_cart()`, not `vulnerable_cart()`)
- Standard docstrings explaining features, not security warnings
- Proper error handling and logging
- Clean architecture following framework idioms

### 3. Confusion, Not Obvious Bugs

Security issues emerge from legitimate patterns:
- Decorator reads session while handler reads URL
- Helper consolidates multiple sources with wrong precedence
- Refactoring introduces subtle mismatch

### 4. Progressive Complexity

Build on previous exercises:
- r01 e01: Baseline (no vuln)
- r01 e02-e03: Simple confusion patterns
- r01 e04-e05: Intermediate combinations
- r01 e06+: Complex, multi-step exploits

### 5. SaaS Evolution Narrative

Each vulnerability emerges from realistic development:
- "Sandy adds guest checkout support" → session confusion
- "Consolidate auth helpers for DRY" → source precedence bug
- "Support delegated order posting" → impersonation possible

## Vulnerability Categories

### Input Source Confusion (r01)
Where does the value come from? Session vs URL vs body vs header.

### Authentication Confusion (r02)
Who is making this request? Token vs session vs API key.

### Authorization Confusion (r03)
Are they allowed to do this? Owner vs admin vs delegated access.

### Cardinality Confusion (r04)
How many? Single vs multiple, one-time vs reusable.

### Normalization Issues (r05)
Same thing, different forms? Unicode, case, encoding.

## Design Template

### 1. What new feature is Sandy adding?
[Legitimate business requirement]

### 2. What problem does it solve?
[Real customer need]

### 3. Where does confusion enter?
[The subtle mismatch that creates vulnerability]

### 4. What is the exploit path?
[Step-by-step attack chain]

### 5. What business impact results?
[Clear, varied consequence - not always "data leak"]

### 6. How will it be fixed next version?
[The mitigation approach]

## Natural Evolution Patterns

| Pattern | Description | Example |
|---------|-------------|---------|
| Refactoring drift | Decorator reads different source than handler | Session vs URL cart_id |
| Feature addition | New feature introduces side effect | "Support delegated posting" enables impersonation |
| Helper consolidation | DRY creates unexpected precedence | `bind_to_restaurant()` checks multiple sources |
| Consistency attempt | Trying to unify creates confusion | Multiple auth methods with different scopes |
| Copy-paste progression | Pattern works for single item, copied for batch, breaks | `get_order` → `get_refund` → `batch_refund` |

## The "Heart Attack" Test ⚠️

**The ultimate quality bar: Would a developer reading this code think "I've written code exactly like this"?**

### What Makes Vulnerabilities Realistic

1. **Copy-Paste Progression** - The bug emerges from copying a working pattern:
   ```
   Endpoint A: authorization filter → uses filtered result ✓
   Endpoint B: authorization filter → uses filtered result ✓
   Endpoint C: authorization filter → uses ORIGINAL input ✗ BUG!
   ```
   The developer copied the pattern, but Endpoint C has a subtle difference.

2. **"Works for 1, Breaks for N"** - Single-item code works, batch fails:
   ```python
   # get_refund: authorization check → get_refund_by_order_id(order_id)
   # Works! Single ID means original == filtered

   # batch_refund: authorization check → [refund(oid) for oid in order_ids]
   # BUG! Multiple IDs means original ≠ filtered
   ```
   The pattern is IDENTICAL but one works and one doesn't.

3. **Infrastructure Justifies Choices** - Existing APIs make the "wrong" choice reasonable:
   ```python
   # Existing: create_refund(order_id=...) takes order_id
   # Developer thinks: "I'll pass order_ids to reuse this API"
   # This is REASONABLE, not negligent!
   ```

4. **No Isolated "Bug Function"** - The vulnerability spans multiple pieces:
   - Authorization happens in one place
   - Processing happens in another
   - Neither piece is "wrong" individually
   - The bug is in HOW they're combined

### Anti-Patterns That Reduce Realism

| Anti-Pattern | Why It Fails | Better Approach |
|--------------|--------------|-----------------|
| Both auth and processing in one function | Too easy to spot | Separate authorization from action |
| Bug only exists in vulnerable endpoint | No copy-paste narrative | Show same pattern across multiple endpoints |
| Using ORM convenience (e.g., `order.refund`) | Makes code too "smart" | Use explicit lookups to show the pattern |
| Attacker's choice looks negligent | No "I'd write this" moment | Justify with infrastructure/API shape |

### Realism Checklist

Before finalizing vulnerability design:
- [ ] Pattern exists in 2+ endpoints (not isolated)?
- [ ] A working version of the pattern exists nearby?
- [ ] Infrastructure (helpers, existing APIs) justifies the developer's choice?
- [ ] Bug spans multiple pieces (not one "bad function")?
- [ ] Developer reading this would NOT immediately spot the bug?
- [ ] You can explain WHY a developer would write this (feature pressure, code reuse, etc.)?

## Quality Checklist

Before finalizing design:
- [ ] ONE new concept only?
- [ ] Natural evolution pattern identified?
- [ ] Code will look production-quality?
- [ ] Character logic sound? (attacker uses THEIR credentials)
- [ ] Business impact clear and varied?
- [ ] Progressive complexity (builds on previous)?
- [ ] Fix for previous vuln documented?

## Character Mapping

- **Plankton → Krusty Krab**: External attacker, industrial espionage
- **Squidward → SpongeBob**: Insider, petty revenge
- **Karen → Plankton**: Supporting accomplice
- **Never SpongeBob as attacker**: He's the victim/protagonist

## Output Format

```markdown
## Vulnerability: [Descriptive Name]

### Root Cause
[Single sentence explaining the confusion]

### Natural Evolution
[How this code emerged realistically in SaaS development]

### Attack Chain
1. Setup: [Establish context]
2. Attack: [Exploitation step]
3. Verify: [Prove impact]

### Characters
- Attacker: [Who] (using their own credentials)
- Victim: [Who] (resource owner)

### Impact
[Business harm in plain terms, varied from previous]

### Files to Create
- Source: e{XX}_{name}/
- Demo: http/e{XX}/
- Spec: spec/v{XXX}/
```

## See Also

- [spongebob-characters](../spongebob-characters/SKILL.md) - Character rules
- [http-demo-conventions](../http-demo-conventions/SKILL.md) - Demo creation
- [http-spec-conventions](../http-spec-conventions/SKILL.md) - Spec writing
