---
title: Races and Missing Synchronization
summary: |
  When multiple requests mutate the same resource without locks or atomic operations, last-write-wins behavior often breaks security promises.
description: |
  ## Overview
  Flask apps scale horizontally, so two identical requests can hit different workers at the same time. Without database constraints, optimistic locking, or distributed locks, shared data such as counters, password reset tokens, or role assignments can fall out of sync. Attackers script rapid requests to win the race and obtain states that should be mutually exclusive.

  **Practice tips:**
  - Use database features such as `SELECT ... FOR UPDATE`, unique indexes, or atomic updates to protect shared state.
  - Consider idempotent designs where repeating the same request has no harmful effect.
  - Monitor for bursts of duplicate requests, which often signal race probing.
category: temporal-inconsistency.races-missing-sync
namespace: flask-temporal-races
toc: true
outline: []
