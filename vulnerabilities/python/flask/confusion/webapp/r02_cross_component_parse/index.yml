version: '1'
root: .
category: confusion
namespace: flask-confusion-cross-component-parse
examples:
  1:
    id: 1
    kind: block
    title: Secure Baseline with Verbose Inline Authentication
    notes: >-
      Demonstrates secure but repetitive authentication. Every endpoint validates credentials
      inline with 4 lines of identical logic before executing business operations. This verbose
      pattern creates pressure to refactor into middleware or decorators, as shown in subsequent
      examples.


      Check out the full routes.py file to see all four endpoints defined there and how much
      code is duplicated here. Pay attention to lack of standardization â€“ even the user identity
      gets extracted in multiple ways:


      - request.form.get("user")

      - request.form.get("sender")

      - request.view_args("username")


      There are no vulnerabilities here, and the code is relatively straightforward to review,
      but the large amount of repetition and inconsistencies make it hard to maintain, which
      typically gets addressed by refactoring into middleware or decorators.
    http: null
    language: python
    parts:
    - part: 1
      file: e01_baseline/routes.py
      code_start_line: 33
      code_end_line: 57
    file_hashes:
      e01_baseline/routes.py: f1e483d8b8ae4554948aebb521dd7ea0593cd338b0c3914b407296b680bfd279
    fingerprint: f0e037ce533c848fa5f5b56169dc4318ea33b9bf2280be3ef03d9e9b74a858ea
  2:
    id: 2
    kind: block
    title: Middleware with Source Precedence Bug
    notes: >-
      This example introduces Flask blueprint middleware to reduce authentication boilerplate.
      The @bp.before_request decorator runs before every endpoint, validates credentials,
      and stores the authenticated user in g.user.


      Note that due to lack of standardization, in the e01_baseline we accessed user identity
      in multiple ways. As we replace the inline authentication with middleware, we standardize
      on a single way to access the user identity.


      While refactoring, developers need to remove previous authentication logic and replace
      the user identity with g.user. However, the `/profile/<username>/view` endpoint accepted
      two usernames - one for authentication (`request.form`) and one for viewing the profile
      (`request.view_args`). This endpoint was refactored correctly - by just removing the
      authentication and keeping the `<username>` for profile access. But then the same method
      was used to refactor the sibling endpoint `/profile/<username>/edit` - introducing a
      source precedence vulnerability.


      An attacker authenticates with their credentials in the form body, then specifies a
      victim's username in the path to edit their profile.
    http: null
    language: python
    parts:
    - part: 1
      file: e02_middleware/routes.py
      code_start_line: 60
      code_end_line: 72
    - part: 2
      file: e02_middleware/routes.py
      code_start_line: 122
      code_end_line: 142
    - part: 3
      file: e02_middleware/routes.py
      code_start_line: 16
      code_end_line: 31
    file_hashes:
      e02_middleware/routes.py: 90f9f98adc8ca9c3b5979e5988a7fe2facf238a49581d5b2420871ef4a95ea5c
    fingerprint: 8ce4dd5dc990c80f5eed874f51341d70fd600cb9f1e1cb952dc8dd71bff67990
  3:
    id: 3
    kind: block
    title: Decorator with `request.values` Confusion
    notes: >-
      Middleware executes on each request within app / blueprint. Real-world apps often need
      different authentication methods, such as having some endpoints unauthenticated or having
      some endpoints authenticated with API keys / service-to-service authn.


      In this example, we move authentication logic to a decorator `@require_auth` - it only
      applies to functions that are explicitly marked with it.


      Decorator uses `request.values` during authentication, which merges user input from
      query string and form body. However, in the `/messages/new` endpoint, the `create_message()`
      function is provided with the sender identity that comes explicitly from `request.form`
      method. Thus, attacker can **impersonate other users** by providing attacker's username
      in the query string, but victim's username and attacker's password in the form body.
    http: null
    language: python
    parts:
    - part: 1
      file: e03_decorator/routes.py
      code_start_line: 30
      code_end_line: 43
    - part: 2
      file: e03_decorator/auth.py
      code_start_line: 12
      code_end_line: 28
    file_hashes:
      e03_decorator/auth.py: 07164d5bc4713b3b4c3e0653cb653f0827494c82c52fdb87701723372d32c49e
      e03_decorator/routes.py: 9607da47fd411232e58426a2861e3f6c02fedeea5085daafa505b899978e28d7
    fingerprint: b021ed773fb532043acf1fcd7c66dcf17f13270bf8164256751fb1f21bcb7d48
  4:
    id: 4
    kind: block
    title: Decorator with Incomplete Fix
    notes: >-
      In this example we attempted to fix the vulnerability by replacing the `request.values`
      method in the decorator with the `request.form` method.


      When we test the previous vulnerability, we see that now it is fixed, which is good
      news.


      However, the fix inadvertently introduced a new vulnerability because the existing code
      in the `/message/list` endpoint accesses the `user` from the combined dictionary `request.values`.
      The attacker can now view victim's messages by sending attacker's credentials via the
      body form (used in `@require_auth`), and the victim's username via the query string
      (used to access the messages).
    http: null
    language: python
    parts:
    - part: 1
      file: e04_decorator_2/routes.py
      code_start_line: 27
      code_end_line: 40
    - part: 2
      file: e04_decorator_2/auth.py
      code_start_line: 12
      code_end_line: 29
    file_hashes:
      e04_decorator_2/auth.py: 28a000ca08fa77ac3838310ffdd8c55d3b747ef306a30eaff716d518780349fb
      e04_decorator_2/routes.py: fa91e37161e134a78aa57a2a7387b9488bcea2867bb82ff74ce463d9603c9948
    fingerprint: 7822d05e762c301a9190c5a235014cee0c7a9e77aa816abdb3b5f860e75c5b93
  5:
    id: 5
    kind: block
    title: Basic Authentication with Query Parameter Bug
    notes: >-
      Modernized authentication using HTTP Basic Auth via Authorization header. User identity
      is now extracted into `g.user` from this header.


      Now the clients won't be sending credentials via the form parameters (HTTP request body)
      anymore. It means:


      1. We are free to use GET method.

      2. We remove a footgun by enforcing a single source of truth for identity.

      Credentials are not mixed with other user input anymore, making it *almost* impossible
      to introduce source confusion bugs.


      Despite this, the endpoint `/profile/<username>/edit` is vulnerable because the profile
      it modifies comes from the path argument without verifying that it matches the authenticated
      user. The vulnerability is hard to spot because it lies deep inside the call stack.
      `get_profile` is built for convenience: it is used both when we edit the profile and
      when we view the profile of other users.
    http: null
    language: python
    parts:
    - part: 1
      file: e05_basic_auth/routes.py
      code_start_line: 91
      code_end_line: 112
    - part: 2
      file: e05_basic_auth/auth.py
      code_start_line: 12
      code_end_line: 34
    - part: 3
      file: e05_basic_auth/db.py
      code_start_line: 42
      code_end_line: 68
    file_hashes:
      e05_basic_auth/auth.py: d3a73c36e722480f8c8c051feedd5d689f4ff74dce7f925ef3bfecb24780ab15
      e05_basic_auth/db.py: bf622c20d579b978ee0ddd191ae087c6d0dbf4c23f2917b558295ebdc6348be0
      e05_basic_auth/routes.py: 182fa7471b495e9d25031ef1f1f0d31fe11f8cd0e5285e5174a5f9ab66b34859
    fingerprint: 4f14623b8c146b0712ff2b486c8ec5d554a14b89d94d8eebb149bfb7a46d30fa
  6:
    id: 6
    kind: block
    title: Error Handler with Fail-Open Vulnerability
    notes: >-
      In this example we showcase two important Flask features: error handler and `after_request`
      middleware. They allow us to remove large amount of code duplication. Compare routes.py
      in this example with the previous example e05.


      The weakness lies withing the `handle_error` function which is meant to sanitize error
      messages to prevent leaking sensitive data. However, when the `error_type` does not
      correspond to any of the keys in the `ERROR_MESSAGES` dictionary, the handler fails
      open and leaks the full exception.


      What goes wrong:

      1. The `profile_is_active` function receives `username` and `profile` parameters, but
      what exactly does it get?

      2. The `username` argument is the verbatim user input from the path, but the `profile`
      is

      the result of `get_profile()` which uses the same `username` input from the path - but
      this time it is sanitized using `sanitize_username()`.

      3. As a result, an attacker can craft a malicious `<username>` which would match existing
      user

      when processed by `sanitize_username()`, but would cause a catastrophic error message
      being logged due to an unhandled exception in `profile_is_active()` function.


      This vulnerability has several layers of weaknesses which when overlap break user's
      confidentiality.
    http: null
    language: python
    parts:
    - part: 1
      file: e06_error_handler/routes.py
      code_start_line: 99
      code_end_line: 109
    - part: 2
      file: e06_error_handler/routes.py
      code_start_line: 24
      code_end_line: 44
    - part: 3
      file: e06_error_handler/db.py
      code_start_line: 78
      code_end_line: 99
    - part: 4
      file: e06_error_handler/db.py
      code_start_line: 42
      code_end_line: 56
    - part: 5
      file: e06_error_handler/security.py
      code_start_line: 15
      code_end_line: 22
    file_hashes:
      e06_error_handler/db.py: 1130859cb0268c3de016c03cd177477c11b7417ceff41341a62dfe9dc555e6fa
      e06_error_handler/routes.py: 3010436c945d701130082e19444fc96495b5dfebfd2fdcf86898b16e69ca64d0
      e06_error_handler/security.py: f736c3f9962af3c44a55356b2540a77924d015fac46fd625c16c16c69b0fb7d4
    fingerprint: 8fc62a679cd4bad19aeb86b2db633c9b84c9a0b864af91c369e5f893b9595d03
attachments:
  http/exploit-1.http: 4f2bbb19aa9d01f72652f3624b97689f64a6632c41a39b0fe1106eafc7619fa6
  http/exploit-2.http: 3f7f022d53e9cffc80a4f391b885a37a7fff2a8a945350b2dc32bcb8edac3f36
  http/exploit-3.http: 7ba5bed5a3081c7ea746603d59700822fdef644eb5961d19af1357676f370607
  http/exploit-4.http: 4cbd4a02de1c8137721ccffefa962be5fe9216eae9b5e6a8a10a69420db10d1f
  http/exploit-5.http: d666522c31d8c42fbb696e245845b7232d929e1ae2535f0526e956fa2b29beec
  http/exploit-6.http: 4e7844cb91f2ca5b87fcc1037d8265bc3e11438fac9283afda6e4e483d13465e
build_signature: 6b6f1212695cb161b569638ed15e79676bba14f97e72b91826320e699686a52d
last_readme_fingerprint: 084cfd596ceece865d87f49a70a17b87b90defb5d150c4373ea17d76d3d18501
