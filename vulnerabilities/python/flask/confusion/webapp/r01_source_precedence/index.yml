version: '1'
root: .
category: ii.source-precedence
namespace: flask-ii-source-precedence
examples:
  1:
    id: 1
    kind: function
    title: Secure Implementation
    notes: >-
      Here you can see a secure implementation that consistently uses query string parameters
      for both authentication and data retrieval.
    http: open
    language: python
    parts:
    - part: 1
      file: e0103_intro/routes.py
      code_start_line: 33
      code_end_line: 51
    file_hashes:
      e0103_intro/routes.py: 49e732e2a49c23cf62186e995151e86f4ded16a296be1eadf682dd15c009939b
    fingerprint: bf2c552e61e747697aa9f2d1908cf5756bd22f4964a4635134494587bd30e288
  2:
    id: 2
    kind: function
    title: Basic Parameter Source Confusion
    notes: >-
      Demonstrates the most basic form of parameter source confusion where authentication
      uses **query** parameters but data retrieval uses **form** data.


      We take the user name from the query string during the validation, but during the data
      retrieval another value is used, taken from the request body (form). This does not look
      very realistic, but it demonstrates the core of the vulnerability, we will build upon
      this further.


      Here you can see if we provide squidward's name in the request body, we can access his
      messages without his password.
    http: null
    language: python
    parts:
    - part: 1
      file: e0103_intro/routes.py
      code_start_line: 68
      code_end_line: 87
    file_hashes:
      e0103_intro/routes.py: 49e732e2a49c23cf62186e995151e86f4ded16a296be1eadf682dd15c009939b
    fingerprint: d7838fdd422904bc22e11c7f6c6da382df561d7ee44ccb18773db33ed0832bda
  3:
    id: 3
    kind: block
    title: Function-Level Parameter Source Confusion
    notes: >-
      Functionally equivalent to example 2, but shows how separating authentication and data
      retrieval into different functions can make the vulnerability harder to spot.
    http: open
    language: python
    parts:
    - part: 1
      file: e0103_intro/routes.py
      code_start_line: 97
      code_end_line: 128
    file_hashes:
      e0103_intro/routes.py: 49e732e2a49c23cf62186e995151e86f4ded16a296be1eadf682dd15c009939b
    fingerprint: 132174e1692c758c7fcaebafed98401e5fddddd2d314738af031fe4858128e5d
  4:
    id: 4
    kind: block
    title: Cross-Module Parameter Source Confusion
    notes: >-
      In the previous example, you can still see that the `user` value gets retrieved from
      the `request.args` during validation but from the `request.form` during data retrieval.


      A more subtle example, where this is not immediately obvious (imagine, `authenticate_user`
      is defined in an another file altogether):
    http: null
    language: python
    parts:
    - part: 1
      file: e04_cross_module/db.py
      code_start_line: 50
      code_end_line: 71
    - part: 2
      file: e04_cross_module/routes.py
      code_start_line: 12
      code_end_line: 27
    file_hashes:
      e04_cross_module/db.py: 85956819c259975983778239ecd055b130937a0c5923b7f4a6f8188b80165771
      e04_cross_module/routes.py: 6ffffe4b4ea079a72d45479582346808c853a6cd3cf5e4a0d737b0cf930c9e99
    fingerprint: fd43d0708fc7b250539180909af9aa40b338a1fd5da4013c29c5d33c4dd029ec
  5:
    id: 5
    kind: block
    title: Mixed-Source Authentication
    notes: >-
      Shows how authentication and data access can use different combinations of sources.


      This one is interesting, because you can access Squidward's messages by providing his
      username and SpongeBob's password in the request query, while providing SpongeBob's
      username in the request body:
    http: null
    language: python
    parts:
    - part: 1
      file: routes.py
      code_start_line: 81
      code_end_line: 118
    file_hashes:
      routes.py: fffcc35b5c91a9643da4fdbc7f1a4b0840f83a1bb2c2d740bdce9bef8d3370f7
    fingerprint: 2ac03a3f2ff24f38a11f7a6030fe1dbf3fbd42e3a153954e377cf3908acbd5a3
  6:
    id: 6
    kind: function
    title: Destructive Parameter Source Confusion
    notes: >-
      Demonstrates parameter source confusion with a DELETE operation. Same root cause as
      Examples 2-5, but now enabling destructive operations instead of just data disclosure.
      Authentication uses query parameters while deletion target uses form body.
    http: null
    language: python
    parts:
    - part: 1
      file: routes.py
      code_start_line: 149
      code_end_line: 171
    file_hashes:
      routes.py: fffcc35b5c91a9643da4fdbc7f1a4b0840f83a1bb2c2d740bdce9bef8d3370f7
    fingerprint: 3db69e55e13e127fdf4370c9ae52d54233882edbbf7884dd8b3a6d4580663bb5
  7:
    id: 7
    kind: block
    title: Form Authentication Bypass
    notes: >-
      The endpoint uses form data for authentication, but request.values.get() allows query
      parameters to override form values, creating a vulnerability. Although designed for
      POST requests, the endpoint accepts both GET and POST methods, enabling the attack.


      Note that although the regular usage would rely on POST request (or PUT, PATCH, etc.),
      and wouldn't work with GET (because flask's request.values ignores form data in GET
      requests), the attacker can send both GET and POST requests (if the endpoint is configured
      to accept both methods).


      ```http

      POST /ii/source-precedence/example7? HTTP/1.1

      Content-Type: application/x-www-form-urlencoded

      Content-Length: 35


      user=spongebob&password=bikinibottom

      ```


      However, the attacker can send both GET and POST requests (if the endpoint is configured
      to accept both methods).
    http: null
    language: python
    parts:
    - part: 1
      file: routes.py
      code_start_line: 192
      code_end_line: 218
    file_hashes:
      routes.py: fffcc35b5c91a9643da4fdbc7f1a4b0840f83a1bb2c2d740bdce9bef8d3370f7
    fingerprint: 937fc872c4b10f8cd4b5e9a5f665583274a7100bc6a4cb8bf7f8bfc6cc102cf8
  8:
    id: 8
    kind: function
    title: Password Reset Parameter Confusion
    notes: >-
      Developers "fixed" the messages endpoint but introduced a NEW vulnerability when adding
      password reset functionality. Authentication uses request.values to verify WHO is making
      the request, but the target user whose password gets reset comes from request.form only.


      An attacker can authenticate with their own credentials in the query string while specifying
      a victim's username in the form body, resetting the victim's password to one they control.
      This enables full account takeover.


      LESSON: This demonstrates how "apparent fixes" create false security. Same root cause
      as Examples 2-7, but now enabling account takeover instead of just data disclosure.
      The partial fix made developers careless when adding new features.
    http: null
    language: python
    parts:
    - part: 1
      file: routes.py
      code_start_line: 265
      code_end_line: 285
    file_hashes:
      routes.py: fffcc35b5c91a9643da4fdbc7f1a4b0840f83a1bb2c2d740bdce9bef8d3370f7
    fingerprint: 1323dbedb73c5365a6664cdbfcc98ec2eefaaffb2a1100a30de106fb7b4d65a8
attachments:
  http/exploit-1.http: 50f85726ba27321f7a75e2f075a6ce5e73cd554912c8941c3f9809d438e71eaa
  http/exploit-2.http: e2811e1f074cdb4b8589caaf500af2f6ea10ba93468c2e92b231666ebbd8670b
  http/exploit-3.http: 885d1ed34ceafe5645ea80d29585573774a7dc8f0a0ec58fd0503e81de6bf477
  http/exploit-4.http: 6369d3570fb27203bbe27ab575d18863d59a2990d6ae91c2e2982bdeb132dd71
  http/exploit-5.http: 513883f3ffbf2d536d25c3e2934a08cb5fedfa2c845b7398e93043720f616f39
  http/exploit-6.http: d8bc1262fd1bfe71b70d4e81cd14bea3c6512a777372b9b4cdd15003009e392b
  http/exploit-7.http: 46cdf284dbd8aad41106b40791ba6d27414e9909951f242094bdcf9437e9b5f8
  http/exploit-8.http: 58c71d9d06c734261fed5d126a7d6cf22dcc17dba323d82242efa3daaeeba5c9
build_signature: 1aff67defb3fd653b285e376fb9cadae53f783a49ed3610a7997f06f68e333ff
last_readme_fingerprint: e2a48b99c5def18c34c49d33ccfd4a6a77a948f18db657bd1a3b789158e474ee
