version: '1'
root: .
category: ii.normalization-canonicalization
namespace: flask-ii-normalization-canonicalization
examples:
  1:
    id: 1
    kind: block
    title: Lowercase Normalization
    notes: >-
      This example demonstrates a canonicalization confusion vulnerability using inconsistent
      lowercase normalization.


      The vulnerability occurs because:


      1. Users can create new groups with any casing (e.g., "STAFF@KRUSTY-KRAB.SEA"), making
      themselves admins


      2. During group membership checks, the group name is NOT normalized/lowercased


      3. When retrieving group messages, the group name IS normalized to lowercase


      Attack scenario: Attacker creates a group "STAFF@KRUSTY-KRAB.SEA" (uppercase) and becomes
      admin. When checking membership, system looks for "STAFF@KRUSTY-KRAB.SEA" (finds attacker's
      group). When retrieving messages, system normalizes to "staff@krusty-krab.sea" (finds
      legitimate group). As a result: Attacker gains access to messages from the legitimate
      group they shouldn't see.
    http: null
    language: python
    parts:
    - part: 1
      file: e01_lowercase/routes.py
      code_start_line: 27
      code_end_line: 40
    file_hashes:
      e01_lowercase/routes.py: cdb97df7af5d72f64c5b9465262548950533b79805c94ae934cd6b33bdf806aa
    fingerprint: dc18920515f1c1e7b3fe9d0ea2cfaeef6b0056d5721561ea6a499b5b7e45bb4d
  2:
    id: 2
    kind: block
    title: Case insensitive Object Retrieval
    notes: >-
      In this example we are still using case canonicalization for group retrieval, but now
      instead of showing the attacker the victim's group content, we are showing the attacker's
      newly created group content to the victim, allowing impersonation.


      The vulnerability occurs when an attacker creates a new group with the same name as
      the victim's group but uses different casing.During group creation, the system checks
      for exact name matches to enforce uniqueness, so "STAFF@KRUSTY-KRAB.SEA" is considered
      different from "staff@krusty-krab.sea" and creation succeeds. However, during group
      retrieval, the system performs case-insensitive matching and returns the most recently
      created group that matches. When the victim tries to access their original group "staff@krusty-krab.sea",
      they actually receive the attacker's group "STAFF@KRUSTY-KRAB.SEA" because it was added
      later and the case-insensitive lookup treats them as the same group.


      This vulnerability allows the attacker to impersonate legitimate group members and post
      messages that appear to come from trusted colleagues or administrators, potentially
      leading to social engineering attacks and information disclosure.
    http: null
    language: python
    parts:
    - part: 1
      file: e02_insensitive_object_retrieval/routes.py
      code_start_line: 27
      code_end_line: 41
    - part: 2
      file: e02_insensitive_object_retrieval/database.py
      code_start_line: 87
      code_end_line: 93
    file_hashes:
      e02_insensitive_object_retrieval/database.py: fcb0e76ab4fa3d2e23cad40b1f2b8829467e8eb1b62ffb262d2832c5a32ddd5d
      e02_insensitive_object_retrieval/routes.py: cb9c82f61b5c04629a760fad7b823bda460e5b3dc416b21ca1bb0b82fc5b0d69
    fingerprint: fcc5200c5ae8ee1d5571667838f0153c05d20b8187b08de68edb77b6aeaeda01
  3:
    id: 3
    kind: block
    title: Whitespace Canonicalization
    notes: >-
      This is a classic whitespace confusion attack - two parts of the code handle whitespace
      differently:

      - strip() only removes leading/trailing whitespace

      - replace(" ", "") removes ALL whitespace


      So here's what happens:

      - @check_group_membership uses strip() - sees "staff @krusty-krab.sea" and keeps the
      middle space

      - example3 uses replace() - turns "staff @krusty-krab.sea" into "staff@krusty-krab.sea"


      The attack: Plankton creates "staff @krusty-krab.sea" (with space), gets authorized
      for HIS group, but the code actually fetches messages from "staff@krusty-krab.sea" (Mr.
      Krabs' group).
    http: null
    language: python
    parts:
    - part: 1
      file: e03_strip_replace_mismatch/routes.py
      code_start_line: 27
      code_end_line: 55
    - part: 2
      file: e03_strip_replace_mismatch/decorator.py
      code_start_line: 36
      code_end_line: 49
    file_hashes:
      e03_strip_replace_mismatch/decorator.py: 07773d7eeadd46784533ab09825e02b50884e575a5bd8acd93ac710108484560
      e03_strip_replace_mismatch/routes.py: 62b565644e54aab48cac2968e8c6017827f538173cd07d7f6cad1afdcf62e8b1
    fingerprint: db12008d6271c1fba3cb03846f52737d3054a05164872828add2515709d0b0a6
  4:
    id: 4
    kind: block
    title: Whitespace Canonicalization
    notes: >-
      Previously we only had 'add group' functionality. Now we add group update handler as
      well. There are two distinct API endpoints now, one creates a new group (and we make
      sure to check that the group truly does not exist yet!), and the other endpoint updates
      the existing group (this is privileged operation, so we check that the user is an admin
      with @check_if_admin decorator).


      Unfortunately, the code remains vulnerable to canonicalization confusion attack. In
      the `create_group` handler we perform group uniqueness check on the raw group name provided
      by user `request.json.get("name")`. However, if the check passes, the `create_new_group`
      is called with the canonicalized data in the Group object. Group model uses `constr`
      feature from pydantic, which strips whitespace on insertion, so the attacker can bypass
      group uniqueness check by providing a group name with extra whitespace at the start
      or end of the group name.


      Compare the exploit to exploit-2.http. Here the impact is much worse, because instead
      of ovewriting the existing group (and losing its message history), this time Plankton
      can simply add himself to the group admins, getting privileged access to existing group
      and its messages. This happens because DatabaseStorage.add_group_to_storage tries to
      be idempotent and cleverly creates a new group if it doesn't exist yet while only updating
      permissions of an existing group. As a result, even though `create_group` and `update_group`
      are meant to be separate handlers, in fact they only differ in the security check implementations,
      while the downstream code path is shared. So by bypassing group uniqueness check in
      `create_group` Plankton in fact manages to use this handler as if it was `update_group`
      - while he wouldn't be able to use `update_group` directly.


      The root cause of the attack is again an inconsistent canonicalization: when we check
      for group existence, we use raw input, but when we store the group, we use canonicalized
      data.
    http: null
    language: python
    parts:
    - part: 1
      file: e04_pydantic_strip_bypass/routes.py
      code_start_line: 49
      code_end_line: 94
    - part: 2
      file: e04_pydantic_strip_bypass/database/models.py
      code_start_line: 21
      code_end_line: 24
    - part: 3
      file: e04_pydantic_strip_bypass/database/storage.py
      code_start_line: 33
      code_end_line: 51
    file_hashes:
      e04_pydantic_strip_bypass/database/models.py: 6d0308ac37f245cf26b363ee4fae7fda77a8298eff9e67e97bbd010c865a9ae6
      e04_pydantic_strip_bypass/database/storage.py: 954ff4f533193adef53e5076b74d0ef457b8171a1609b0e7f971f0adee2ff158
      e04_pydantic_strip_bypass/routes.py: 7bded7a662c53aeea1019493207a60af43b1a4ad2ec16c489b7a69ab10371c49
    fingerprint: f231cf50c9ee0a4a4f8ccaf2673780fe6c600cf62331195ef76e7f6cb344c451
attachments:
  http/exploit-1.http: e6763388648214bb712a7120f73328493e2f027efdcd475e5d56cb7028cae178
  http/exploit-2.http: 3675aa10205994b17a4028b8054382171dd2bd6e61676e9ca65879d3ba8be179
  http/exploit-3.http: 833fd0ccdbce44c80e50f151aeebcc38b5dc72133e7149551c441e0a0007e4ad
  http/exploit-4.http: 492c0b00c30fa061b16398757d193c8a503d87d79c31a172e84b8a7781711eaa
build_signature: b4304d009bbf53a46877d2672284e0c4b79b700e20f4e3db03197213af97d26d
last_readme_fingerprint: e4232197a6bfe58becd0c8718b87fda608eef086f594bc4a6cd7eb3b3b68c689
