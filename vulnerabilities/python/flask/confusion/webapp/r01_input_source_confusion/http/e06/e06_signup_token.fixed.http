# @import ../common/setup.http
@host = {{base_host}}/v107
@mailpit = http://127.0.0.1:8025/api/v1


### Sandy fixes vulnerability and tests the mitigation
POST /auth/register
Content-Type: application/json

{ "email": "sandy+test@bikinibottom.sea" }

?? status == 200


### This request succeeds and sends a verification email to provided email
GET {{mailpit}}/messages?limit=1

@message_id = {{response.parsedBody.messages.at(-1).ID}}
?? status == 200


### Extract the verification token from the email
GET {{mailpit}}/message/{{message_id}}

@token = {{response.parsedBody.Text.match(/token=([a-zA-Z0-9\-_.]+)/)[1]}}
?? status == 200


### Sandy replays Plankton's attack, providing her own email with a valid token
POST /auth/register
Content-Type: application/json

{
    "token": "{{token}}",
    "email": "sandy@bikinibottom.sea",
    "password": "hijacked",
    "name": "Sandy Test"
}

?? status == 200
// The user gets created, but the system uses the email from the verification token
?? js response.parsedBody.email == sandy+test@bikinibottom.sea


### The attack fails, because Sandy's real account is NOT hijacked
GET /account/info
Authorization: Basic sandy@bikinibottom.sea:hijacked

// Error as expected
HTTP/1.1 400 Bad Request
{
  "error": "User authentication required"
}

?? status == 400


### Meanwhile, Sandy can access her own account with real credentials
GET /account/info
Authorization: {{sandy_auth_email}}

?? status == 200
?? js response.parsedBody.email == sandy@bikinibottom.sea
