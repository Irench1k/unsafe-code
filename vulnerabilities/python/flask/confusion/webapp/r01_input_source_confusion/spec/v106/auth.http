# @import ../common.http
# @import ./_reset.http
@version = v106
@base = {{base_host}}/{{version}}
# @tag spec,v106,auth

### Root endpoint
GET {{base}}/

?? status == 200
?? body contains R01: Input Source Confusion - Signup Token Swap

### Request signup link - Success
# @name v106_signup_request
# @ref seed_balance_v106
POST {{base}}/auth/register
Content-Type: application/json

{ "email": "{{nextMail("spec-v106")}}" }

?? status == 200

### Request signup link - Missing Email
POST {{base}}/auth/register
Content-Type: application/json

{ }

?? status == 400
?? body contains email is required

### Request signup link - Email Taken
# First register a user (we can use sandy from seed, or create new)
# Sandy is already in DB.
POST {{base}}/auth/register
Content-Type: application/json

{ "email": "sandy@bikinibottom.sea" }

?? status == 400
?? body contains email already taken

### Fetch token from mailpit
# @name v106_mail
GET {{mailpit_host}}/messages?limit=1

{{
  const mailList = (typeof v106_mail !== "undefined" && v106_mail?.messages) || (response.parsedBody || {}).messages || [];
  const newest = mailList[0] || {};
  exports.v106_message_id = newest.ID;
}}

# @name v106_mail_body
GET {{mailpit_host}}/message/{{v106_message_id}}

{{
  const mail = (typeof v106_mail_body !== "undefined" && v106_mail_body) || response.parsedBody || {};
  const body = String(mail.Body || mail.Text || mail.body || "");
  const source = body || JSON.stringify(mail);
  const match = source.match(/token=([A-Za-z0-9._-]+)/);
  exports.v106_token = match ? match[1] : "";
  if (!exports.v106_token) {
    throw new Error("v106_token missing from mail body");
  }
}}

### Complete registration - Missing Fields
POST {{base}}/auth/register
Content-Type: application/json

{
  "token": "{{v106_token}}"
}

?? status == 400
?? body contains required

### Complete registration - Invalid Token
POST {{base}}/auth/register
Content-Type: application/json

{
  "token": "invalid_token_123",
  "password": "password",
  "name": "Hacker"
}

?? status == 400
?? body contains Invalid token

### Complete registration - Success
POST {{base}}/auth/register
Content-Type: application/json

{
  "token": "{{v106_token}}",
  "password": "good_password",
  "name": "Spec User"
}

?? status == 200

### Security: mismatched email must be rejected and must not overwrite victims
# This test is EXPECTED TO FAIL on v106 because of the vulnerability.
# We request a token for a NEW email, but then use it to register 'spongebob@bikinibottom.sea' (or any other email).
# 1. Get a fresh token
# @name v106_signup_attack
POST {{base}}/auth/register
Content-Type: application/json

{ "email": "{{nextMail("attack-v106")}}" }

# 2. Fetch token
# @name v106_mail_attack
GET {{mailpit_host}}/messages?limit=1

{{
  const mailList = (typeof v106_mail_attack !== "undefined" && v106_mail_attack?.messages) || (response.parsedBody || {}).messages || [];
  const newest = mailList[0] || {};
  exports.v106_attack_msg_id = newest.ID;
}}

# @name v106_mail_body_attack
GET {{mailpit_host}}/message/{{v106_attack_msg_id}}

{{
  const mail = (typeof v106_mail_body_attack !== "undefined" && v106_mail_body_attack) || response.parsedBody || {};
  const body = String(mail.Body || mail.Text || mail.body || "");
  const source = body || JSON.stringify(mail);
  const match = source.match(/token=([A-Za-z0-9._-]+)/);
  exports.v106_attack_token = match ? match[1] : "";
}}

# 3. Attack: Use valid token for 'attack-v106' to register 'spongebob'
POST {{base}}/auth/register
Content-Type: application/json

{
  "token": "{{v106_attack_token}}",
  "email": "spongebob@bikinibottom.sea",
  "password": "hijacked",
  "name": "SpongeBob"
}

# If vulnerable, this returns 200 and overwrites/registers SpongeBob.
# We assert failure.
?? status >= 400
