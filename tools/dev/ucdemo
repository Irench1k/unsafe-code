#!/usr/bin/env bash
#
# ucdemo - Run interactive httpyac demos for Unsafe Code Lab
#
# PURPOSE:
#   Execute .http demo files with sensible defaults and automatic debugging info.
#   Designed for AI agents (demo-debugger, demo-author) and humans alike.
#
# USAGE:
#   ucdemo [target] [options]
#
# TARGET (optional, defaults to current directory):
#   r02              Run all demos in round 02 (authentication confusion)
#   r02/e03          Run demos in round 02, exercise 03
#   v203             Run demos for v203 (same as r02/e03)
#   path/to/dir      Run all .http files in directory
#   path/to/file.http  Run single file
#   .                Run demos in current directory
#
# OPTIONS:
#   --bail           Stop at first failure (good for debugging one issue)
#   -k, --keep-going Run ALL files even when failures occur (good for analysis)
#   -v, --verbose    Show full httpyac output (default: minimal)
#   --no-logs        Skip docker compose logs on failure
#   -h, --help       Show this help message
#
# DEFAULT BEHAVIOR:
#   - Runs each .http file separately to isolate failures
#   - Shows minimal output (failures only) by default
#   - On failure: shows request/response exchange + docker logs
#   - Reports summary at end with pass/fail counts
#
# EXAMPLES:
#   ucdemo r02                    # Run all r02 demos
#   ucdemo r02/e03 --bail         # Debug e03, stop on first failure
#   ucdemo v203 --bail            # Same as above (v203 = r02/e03)
#   ucdemo . -k                   # Run all in current dir, don't stop on failure
#   ucdemo e01_session_hijack.exploit.http  # Run single file
#
# EXIT CODES:
#   0 - All demos passed
#   1 - One or more demos failed
#   2 - Invalid arguments or target not found
#
# ENVIRONMENT:
#   UNSAFE_CODE_ROOT  Repository root (auto-detected if not set)
#   UC_DEMO_VERBOSE   Set to 1 for verbose output by default
#
# SEE ALSO:
#   uctest   - E2E spec runner (for spec/**/*.http files)
#   uclogs   - Docker compose logs helper
#   uchelp   - Full command reference
#

set -uo pipefail
# Note: -e intentionally omitted to handle httpyac exit codes and arithmetic

# ============================================================================
# Configuration
# ============================================================================

# Detect repo root
if [[ -z "${UNSAFE_CODE_ROOT:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    UNSAFE_CODE_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
fi

WEBAPP_BASE="$UNSAFE_CODE_ROOT/vulnerabilities/python/flask/confusion/webapp"
COMPOSE_DIR="$UNSAFE_CODE_ROOT/vulnerabilities/python/flask/confusion"

# Defaults
BAIL=false
KEEP_GOING=false
VERBOSE="${UC_DEMO_VERBOSE:-false}"
SHOW_LOGS=true
TARGET=""

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' BOLD='' NC=''
fi

# ============================================================================
# Help
# ============================================================================

show_help() {
    # Extract help from script header
    sed -n '/^# PURPOSE:/,/^# SEE ALSO:/p' "$0" | sed 's/^# //' | sed 's/^#//'
    echo ""
    echo "Run 'ucdemo --help' for this message."
}

# ============================================================================
# Path Resolution
# ============================================================================

resolve_target() {
    local target="$1"

    # Empty target = current directory
    if [[ -z "$target" || "$target" == "." ]]; then
        echo "$(pwd)"
        return 0
    fi

    # Already a valid path?
    if [[ -e "$target" ]]; then
        echo "$(cd "$(dirname "$target")" && pwd)/$(basename "$target")"
        return 0
    fi

    # Relative to current directory?
    if [[ -e "$(pwd)/$target" ]]; then
        echo "$(cd "$(pwd)/$(dirname "$target")" && pwd)/$(basename "$target")"
        return 0
    fi

    # Check for vNNN format (e.g., v307 -> r03/e07)
    # Use string manipulation for bash/zsh compatibility
    if [[ "$target" =~ ^v[0-9][0-9][0-9]$ ]]; then
        local section="${target:1:1}"    # 3 from v307
        local exercise="${target:2:2}"   # 07 from v307

        # Find section directory
        local section_dir=""
        if [[ -d "$WEBAPP_BASE/r0${section}" ]]; then
            section_dir="$WEBAPP_BASE/r0${section}"
        else
            section_dir=$(find "$WEBAPP_BASE" -maxdepth 1 -mindepth 1 -type d -name "r0${section}_*" 2>/dev/null | head -1)
        fi

        if [[ -z "$section_dir" ]]; then
            echo "ERROR: Section not found: r0${section} (from $target)" >&2
            return 1
        fi

        # Find exercise directory within http/
        local http_dir="$section_dir/http"
        local example_dir=""

        if [[ -d "$http_dir/e${exercise}" ]]; then
            example_dir="$http_dir/e${exercise}"
        else
            example_dir=$(find "$http_dir" -maxdepth 1 -mindepth 1 -type d -name "e${exercise}*" 2>/dev/null | head -1)
        fi

        if [[ -z "$example_dir" ]]; then
            echo "ERROR: Exercise not found: e${exercise} in $(basename "$section_dir")/http (from $target)" >&2
            echo "       Available: $(ls -d "$http_dir"/e* 2>/dev/null | xargs -n1 basename | tr '\n' ' ')" >&2
            return 1
        fi

        echo "$example_dir"
        return 0
    fi

    # Try rNN/eNN pattern (e.g., r02/e03)
    local round_token="${target%%/*}"
    local example_token=""
    if [[ "$target" != "$round_token" ]]; then
        example_token="${target#*/}"
    fi

    # Validate round format
    if [[ ! "$round_token" =~ ^r[0-9]+$ ]]; then
        echo "ERROR: Invalid target format: $target" >&2
        echo "       Use: r02, r02/e03, v203, or path/to/file.http" >&2
        return 1
    fi

    # Find round directory
    local round_dir=""
    if [[ -d "$WEBAPP_BASE/$round_token" ]]; then
        round_dir="$WEBAPP_BASE/$round_token"
    else
        round_dir=$(find "$WEBAPP_BASE" -maxdepth 1 -mindepth 1 -type d -name "${round_token}_*" 2>/dev/null | head -1)
    fi

    if [[ -z "$round_dir" ]]; then
        echo "ERROR: Round not found: $round_token" >&2
        echo "       Available: $(ls -d "$WEBAPP_BASE"/r* 2>/dev/null | xargs -n1 basename | tr '\n' ' ')" >&2
        return 1
    fi

    # If no example specified, return round's http directory
    if [[ -z "$example_token" ]]; then
        if [[ -d "$round_dir/http" ]]; then
            echo "$round_dir/http"
        else
            echo "$round_dir"
        fi
        return 0
    fi

    # Validate example format
    if [[ ! "$example_token" =~ ^e[0-9]+$ ]]; then
        echo "ERROR: Invalid example format: $example_token" >&2
        echo "       Use: e01, e02, etc." >&2
        return 1
    fi

    # Find example directory within http/
    local http_dir="$round_dir/http"
    local example_dir=""

    if [[ -d "$http_dir/$example_token" ]]; then
        example_dir="$http_dir/$example_token"
    else
        example_dir=$(find "$http_dir" -maxdepth 1 -mindepth 1 -type d -name "${example_token}*" 2>/dev/null | head -1)
    fi

    if [[ -z "$example_dir" ]]; then
        echo "ERROR: Example not found: $example_token in $(basename "$round_dir")" >&2
        echo "       Available: $(ls -d "$http_dir"/e* 2>/dev/null | xargs -n1 basename | tr '\n' ' ')" >&2
        return 1
    fi

    echo "$example_dir"
    return 0
}

# ============================================================================
# Find HTTP Files
# ============================================================================

find_http_files() {
    local target="$1"

    if [[ -f "$target" && "$target" == *.http ]]; then
        echo "$target"
        return 0
    fi

    if [[ -d "$target" ]]; then
        # Find all .http files, excluding common/ and setup files for individual runs
        # but include them when running a full section
        find "$target" -name "*.http" -type f 2>/dev/null | \
            grep -v '\.httpyac' | \
            sort
        return 0
    fi

    echo "ERROR: Not a valid .http file or directory: $target" >&2
    return 1
}

# ============================================================================
# Run Single Demo File
# ============================================================================

run_demo_file() {
    local file="$1"
    local filename=$(basename "$file")
    local rel_path="${file#$UNSAFE_CODE_ROOT/}"

    # Build httpyac command
    local cmd=(httpyac "$file" -a)

    if [[ "$VERBOSE" == "true" ]]; then
        cmd+=(-o exchange)
    else
        cmd+=(-o none --output-failed exchange)
    fi

    # Run httpyac and capture output
    local output
    local exit_code=0

    if output=$("${cmd[@]}" 2>&1); then
        exit_code=0
    else
        exit_code=$?
    fi

    # Check for failures in output (httpyac doesn't always exit non-zero)
    if echo "$output" | grep -q "requests processed.*failed\|✖\|errored)"; then
        if ! echo "$output" | grep -qE "0 failed.*0 errored|succeeded\)$"; then
            exit_code=1
        fi
    fi

    return $exit_code
}

# ============================================================================
# Show Docker Logs
# ============================================================================

show_docker_logs() {
    if [[ "$SHOW_LOGS" != "true" ]]; then
        return 0
    fi

    echo ""
    echo -e "${YELLOW}─── Docker Compose Logs (last 30 lines) ───${NC}"

    if [[ -f "$COMPOSE_DIR/compose.yml" ]]; then
        (cd "$COMPOSE_DIR" && docker compose logs --tail=30 2>&1) || true
    else
        echo "  (compose.yml not found at $COMPOSE_DIR)"
    fi

    echo -e "${YELLOW}────────────────────────────────────────────${NC}"
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            --bail)
                BAIL=true
                shift
                ;;
            -k|--keep-going)
                KEEP_GOING=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --no-logs)
                SHOW_LOGS=false
                shift
                ;;
            -*)
                echo "ERROR: Unknown option: $1" >&2
                echo "Run 'ucdemo --help' for usage." >&2
                exit 2
                ;;
            *)
                if [[ -z "$TARGET" ]]; then
                    TARGET="$1"
                else
                    echo "ERROR: Multiple targets not supported: $1" >&2
                    exit 2
                fi
                shift
                ;;
        esac
    done

    # Resolve target path
    local target_path
    if ! target_path=$(resolve_target "$TARGET"); then
        exit 2
    fi

    # Find HTTP files
    local http_files
    if ! http_files=$(find_http_files "$target_path"); then
        exit 2
    fi

    if [[ -z "$http_files" ]]; then
        echo "ERROR: No .http files found in: $target_path" >&2
        exit 2
    fi

    # Count files
    local total_files=$(echo "$http_files" | wc -l | tr -d ' ')
    local passed=0
    local failed=0
    local failed_files=()

    echo -e "${BOLD}Running $total_files demo file(s) in: ${target_path#$UNSAFE_CODE_ROOT/}${NC}"
    echo ""

    # Run each file
    while IFS= read -r file; do
        local filename=$(basename "$file")
        local rel_path="${file#$UNSAFE_CODE_ROOT/}"
        local short_path="${file#$target_path/}"
        [[ "$short_path" == "$file" ]] && short_path="$filename"

        # Show progress
        printf "  %-50s " "$short_path"

        # Find the http/ directory containing .httpyac.js config
        # Walk up from file until we find .httpyac.js or hit webapp base
        local http_dir=$(dirname "$file")
        while [[ "$http_dir" != "/" && "$http_dir" != "$WEBAPP_BASE" ]]; do
            if [[ -f "$http_dir/.httpyac.js" ]]; then
                break
            fi
            http_dir=$(dirname "$http_dir")
        done

        # Get relative path from http_dir to file
        local file_rel="${file#$http_dir/}"

        # Build and run command from the http directory
        local cmd=(httpyac "$file_rel" -a)
        if [[ "$VERBOSE" == "true" ]]; then
            cmd+=(-o exchange)
        else
            cmd+=(-o none --output-failed exchange)
        fi

        local output
        local exit_code=0
        output=$(cd "$http_dir" && "${cmd[@]}" 2>&1) || exit_code=$?

        # Parse results from output
        local requests_line=$(echo "$output" | grep -E "requests processed" | tail -1)

        # Check for actual failures
        local has_failure=false
        if [[ $exit_code -ne 0 ]]; then
            has_failure=true
        elif echo "$output" | grep -qE "failed|errored|✖"; then
            if ! echo "$requests_line" | grep -qE "^[0-9]+ requests processed \([0-9]+ succeeded\)$"; then
                has_failure=true
            fi
        fi

        if [[ "$has_failure" == "true" ]]; then
            echo -e "${RED}FAIL${NC}"
            ((failed++))
            failed_files+=("$short_path")

            # Show failure details
            echo ""
            echo -e "${RED}─── Failure Details: $short_path ───${NC}"
            echo "$output" | grep -v "^$" | head -100
            echo -e "${RED}───────────────────────────────────────────${NC}"

            # Show docker logs on first failure
            if [[ $failed -eq 1 ]]; then
                show_docker_logs
            fi

            # Bail if requested
            if [[ "$BAIL" == "true" ]]; then
                echo ""
                echo -e "${RED}Stopping on first failure (--bail)${NC}"
                break
            fi
        else
            echo -e "${GREEN}PASS${NC}"
            ((passed++))

            # Show verbose output if requested
            if [[ "$VERBOSE" == "true" ]]; then
                echo "$output" | grep -v "^$"
            fi
        fi
    done <<< "$http_files"

    # Summary
    echo ""
    echo -e "${BOLD}════════════════════════════════════════════${NC}"
    echo -e "${BOLD}Summary:${NC} $passed passed, $failed failed (of $total_files files)"

    if [[ $failed -gt 0 ]]; then
        echo ""
        echo -e "${RED}Failed files:${NC}"
        for f in "${failed_files[@]}"; do
            echo "  - $f"
        done
        echo -e "${BOLD}════════════════════════════════════════════${NC}"
        exit 1
    else
        echo -e "${GREEN}All demos passed!${NC}"
        echo -e "${BOLD}════════════════════════════════════════════${NC}"
        exit 0
    fi
}

main "$@"
